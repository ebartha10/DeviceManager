import { useState, useEffect } from "react";
import { Outlet, useLocation, Link as RouterLink } from "react-router";
// @ts-expect-error - Route types are generated by React Router
import type { Route } from "../+types/dashboard";
import { deviceApi, type Device } from "../../api/deviceApi";
import { tokenStorage } from "../../api/tokenStorage";
import {
  Dashboard as DashboardIcon,
  Person as PersonIcon,
  Settings as SettingsIcon,
  Add as AddIcon,
  Edit as EditIcon,
  Delete as DeleteIcon,
} from "@mui/icons-material";
import {
  DashboardContainer,
  Sidebar,
  LogoContainer,
  LogoIcon,
  AppTitle,
  UserProfileCard,
  UserAvatar,
  UserInfoContainer,
  UserName,
  UserEmail,
  NavigationSection,
  NavigationHeading,
  ActiveNavLink,
  InactiveNavRouterLink,
  MainContent,
  PageHeader,
  PageTitleContainer,
  PageTitle,
  PageSubtitle,
  PrimaryActionButton,
  DeviceCardsContainer,
  DeviceCardCyan,
  DeviceCardPink,
  DeviceCardYellow,
  DeviceInfoContainer,
  DeviceName,
  DeviceTypeCyan,
  DeviceTypePink,
  DeviceTypeYellow,
  DeviceMetricsContainer,
  MetricItem,
  MetricLabel,
  MetricValueGreen,
  MetricValuePink,
  MetricValueYellow,
  MetricValueCyan,
  MetricDotGreen,
  MetricDotPink,
  MetricDotYellow,
  MetricDotCyan,
  DeviceActionsContainer,
  EditButtonCyan,
  EditButtonPink,
  EditButtonYellow,
  DeleteButton,
  StyledDialog,
  StyledDialogTitle,
  StyledDialogContent,
  StyledDialogActions,
  DialogTextField,
  DialogPrimaryButton,
  DialogCancelButton,
  DialogAutocomplete,
  DeviceDetailsContainer,
  DeviceDetailsLabel,
  DeviceDetailsText,
} from "./StyledComponents";

export function meta({}: Route.MetaArgs) {
  return [
    { title: "NEXUS - Dashboard" },
    { name: "description", content: "NEXUS Device Management Dashboard" },
  ];
}

export default function Dashboard() {
  const location = useLocation();
  const isDashboard = location.pathname === "/dashboard" || location.pathname === "/dashboard/";
  const isProfile = location.pathname === "/dashboard/profile";

  // Modal state
  const [addDeviceOpen, setAddDeviceOpen] = useState(false);
  const [selectedDevice, setSelectedDevice] = useState<Device | null>(null);
  const [availableDevices, setAvailableDevices] = useState<Device[]>([]);
  const [userDevices, setUserDevices] = useState<Device[]>([]);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    if (typeof window !== "undefined") {
      loadUserDevices();
    }
  }, []);

  useEffect(() => {
    if (addDeviceOpen && typeof window !== "undefined") {
      loadAvailableDevices();
    }
  }, [addDeviceOpen]);

  const loadUserDevices = async () => {
    try {
      setLoading(true);
      const userId = tokenStorage.getUserId();
      if (userId) {
        const devicesData = await deviceApi.getDevicesForUser(userId);
        setUserDevices(devicesData);
      }
    } catch (error) {
      console.error("Error loading user devices:", error);
    } finally {
      setLoading(false);
    }
  };

  const loadAvailableDevices = async () => {
    try {
      const allDevices = await deviceApi.getAllDevices();
      const userId = tokenStorage.getUserId();
      
      // Get devices the user already has
      let userDeviceIds: string[] = [];
      if (userId) {
        try {
          const userDevs = await deviceApi.getDevicesForUser(userId);
          userDeviceIds = userDevs.map(d => d.id);
        } catch (error) {
          console.error("Error loading user devices:", error);
        }
      }
      
      // Filter out devices the user already has
      const available = allDevices.filter(device => !userDeviceIds.includes(device.id));
      setAvailableDevices(available);
    } catch (error) {
      console.error("Error loading available devices:", error);
    }
  };

  const handleAddDevice = async () => {
    if (!selectedDevice) return;
    
    try {
      const userId = tokenStorage.getUserId();
      if (!userId) {
        alert("Please log in again.");
        return;
      }
      
      await deviceApi.addDeviceForUser({
        userId,
        deviceId: selectedDevice.id,
      });
      setAddDeviceOpen(false);
      setSelectedDevice(null);
      await loadUserDevices();
    } catch (error) {
      console.error("Error adding device to user:", error);
      alert("Failed to add device. Please try again.");
    }
  };

  const GearSVG = () => (
    <svg
      width="28"
      height="28"
      viewBox="0 0 24 24"
      fill="none"
      xmlns="http://www.w3.org/2000/svg"
    >
      <circle cx="12" cy="12" r="3" fill="white" />
      <path
        d="M12 1v6m0 6v6m11-7h-6m-6 0H1m16.364-5.636l-4.243 4.243m0 4.243l4.243 4.243M6.636 6.636L2.393 2.393m0 15.214l4.243-4.243"
        stroke="white"
        strokeWidth="1.5"
        strokeLinecap="round"
      />
    </svg>
  );

  // Transform API devices to display format
  const deviceDisplayData = userDevices.map((device, index) => {
    const colors = ["#00ffff", "#ff00ff", "#ffff00"];
    const borders = ["cyan", "pink", "yellow"];
    const colorIndex = index % colors.length;
    
    return {
      id: device.id,
      name: device.name || "Unnamed Device",
      type: device.type || "Unknown",
      typeColor: colors[colorIndex],
      borderColor: borders[colorIndex],
      metrics: [
        { label: "Status", value: "Online", color: "#00ff00" },
        { label: "Uptime", value: "99%", color: "#00ffff" },
      ],
    };
  });

  const getMetricComponent = (color: string) => {
    if (color === "#00ff00") return { Dot: MetricDotGreen, Value: MetricValueGreen };
    if (color === "#ff00ff") return { Dot: MetricDotPink, Value: MetricValuePink };
    if (color === "#ffff00") return { Dot: MetricDotYellow, Value: MetricValueYellow };
    if (color === "#00ffff") return { Dot: MetricDotCyan, Value: MetricValueCyan };
    return { Dot: MetricDotGreen, Value: MetricValueGreen };
  };

  const getEditButton = (typeColor: string) => {
    if (typeColor === "#00ffff") return EditButtonCyan;
    if (typeColor === "#ff00ff") return EditButtonPink;
    if (typeColor === "#ffff00") return EditButtonYellow;
    return EditButtonCyan;
  };

  const renderDeviceCard = (device: typeof devices[0]) => {
    const CardComponent =
      device.borderColor === "cyan"
        ? DeviceCardCyan
        : device.borderColor === "pink"
        ? DeviceCardPink
        : DeviceCardYellow;

    const TypeComponent =
      device.typeColor === "#00ffff"
        ? DeviceTypeCyan
        : device.typeColor === "#ff00ff"
        ? DeviceTypePink
        : DeviceTypeYellow;

    const EditButtonComponent = getEditButton(device.typeColor);

    return (
      <CardComponent key={device.id}>
        <DeviceInfoContainer>
          <DeviceName>{device.name}</DeviceName>
          <TypeComponent>{device.type}</TypeComponent>
        </DeviceInfoContainer>
        <DeviceMetricsContainer>
          {device.metrics.map((metric, index) => {
            const { Dot, Value } = getMetricComponent(metric.color);
            return (
              <MetricItem key={index}>
                <Dot />
                <MetricLabel>{metric.label}</MetricLabel>
                <Value>{metric.value}</Value>
              </MetricItem>
            );
          })}
        </DeviceMetricsContainer>
        <DeviceActionsContainer>
          <EditButtonComponent>
            <EditIcon />
          </EditButtonComponent>
          <DeleteButton>
            <DeleteIcon />
          </DeleteButton>
        </DeviceActionsContainer>
      </CardComponent>
    );
  };

  return (
    <DashboardContainer>
      <Sidebar>
        <LogoContainer>
          <LogoIcon>
            <GearSVG />
          </LogoIcon>
          <AppTitle>NEXUS</AppTitle>
        </LogoContainer>

        <UserProfileCard>
          <UserAvatar>JD</UserAvatar>
          <UserInfoContainer>
            <UserName>John Doe</UserName>
            <UserEmail>john.doe@nexus.com</UserEmail>
          </UserInfoContainer>
        </UserProfileCard>

        <NavigationSection>
          <NavigationHeading>NAVIGATION</NavigationHeading>
          {isDashboard ? (
            <ActiveNavLink startIcon={<DashboardIcon />} fullWidth>
              Dashboard
            </ActiveNavLink>
          ) : (
            <InactiveNavRouterLink to="/dashboard">
              <DashboardIcon />
              Dashboard
            </InactiveNavRouterLink>
          )}
          {isProfile ? (
            <ActiveNavLink startIcon={<PersonIcon />} fullWidth>
              Profile
            </ActiveNavLink>
          ) : (
            <InactiveNavRouterLink to="/dashboard/profile">
              <PersonIcon />
              Profile
            </InactiveNavRouterLink>
          )}
          <InactiveNavRouterLink to="/dashboard/settings">
            <SettingsIcon />
            Settings
          </InactiveNavRouterLink>
        </NavigationSection>
      </Sidebar>

      <MainContent>
        {isDashboard ? (
          <>
            <PageHeader>
              <PageTitleContainer>
                <PageTitle>DEVICE MANAGEMENT</PageTitle>
                <PageSubtitle>Monitor and control your connected devices</PageSubtitle>
              </PageTitleContainer>
              <PrimaryActionButton
                startIcon={<AddIcon />}
                onClick={() => setAddDeviceOpen(true)}
              >
                ADD DEVICE
              </PrimaryActionButton>
            </PageHeader>

            <DeviceCardsContainer>
              {deviceDisplayData.map(renderDeviceCard)}
            </DeviceCardsContainer>
          </>
        ) : (
          <Outlet />
        )}

        {/* Add Device Modal */}
        <StyledDialog
          open={addDeviceOpen}
          onClose={() => {
            setAddDeviceOpen(false);
            setSelectedDevice(null);
          }}
          maxWidth="sm"
          fullWidth
        >
          <StyledDialogTitle>ADD DEVICE TO ACCOUNT</StyledDialogTitle>
          <StyledDialogContent>
            <DialogAutocomplete
              options={availableDevices}
              value={selectedDevice}
              onChange={(event, newValue) => {
                setSelectedDevice(newValue);
              }}
              getOptionLabel={(option) => 
                `${option.name || "Unnamed Device"} (${option.type || "Unknown"})`
              }
              isOptionEqualToValue={(option, value) => option.id === value.id}
              renderInput={(params) => (
                <DialogTextField
                  {...params}
                  label="Select Device"
                  placeholder="Search devices..."
                  variant="outlined"
                />
              )}
              loading={availableDevices.length === 0}
              noOptionsText={
                availableDevices.length === 0
                  ? "Loading devices..."
                  : "No available devices found"
              }
            />
            {selectedDevice && (
              <DeviceDetailsContainer>
                <DeviceDetailsLabel>Device Details:</DeviceDetailsLabel>
                <DeviceDetailsText>
                  <strong>Name:</strong> {selectedDevice.name || "Unnamed Device"}
                </DeviceDetailsText>
                <DeviceDetailsText>
                  <strong>Type:</strong> {selectedDevice.type || "Unknown"}
                </DeviceDetailsText>
                {selectedDevice.description && (
                  <DeviceDetailsText>
                    <strong>Description:</strong> {selectedDevice.description}
                  </DeviceDetailsText>
                )}
              </DeviceDetailsContainer>
            )}
          </StyledDialogContent>
          <StyledDialogActions>
            <DialogCancelButton
              onClick={() => {
                setAddDeviceOpen(false);
                setSelectedDevice(null);
              }}
            >
              CANCEL
            </DialogCancelButton>
            <DialogPrimaryButton
              onClick={handleAddDevice}
              disabled={!selectedDevice}
            >
              ADD DEVICE
            </DialogPrimaryButton>
          </StyledDialogActions>
        </StyledDialog>
      </MainContent>
    </DashboardContainer>
  );
}

